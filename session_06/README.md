<div align="justify" dir="rtl">

# مقابله با منطق تجاری پیچیده

به مباحث منطق تجاری رسیدین قلب تپنده هر سیستمی در پست‌های قبلی دو الگوی ساده اسکریپت و الگوی فعال رو بررسی کردیم و در ادامه مباحث منطق تجاری، الگوی دامنه پیچیده رو بررسی میکنیم، الگوی «مدل دامنه» مجموع‌ها و اشیا ارزش بلوک‌های سازنده آن است

الگوی مدل دامنه برای مقابله با موارد منطق تجاری پیچیده در نظر گرفته شده است.
 در اینجا، به‌جای رابط‌های CRUD، با انتقال‌های حالت پیچیده، قوانین تجاری، و متغیرها سروکار داریم: قوانینی که همیشه باید محافظت شوند. برای مثال یک سیستم مدیریت پیام بصورت ارزش گذاری روی پیام‌هارو در نظر بگیرید(یک سیستم help desk) که شامل یکسری الزامات هست که مانند یک شبکه درهم تنیده از وابستگی‌ها قوانینی که همگی بر چرخه حیات سیستم تاثیر گذار است، تلاش برای پیاده سازی این منطق با استفاده از اشیا رکورد فعال تکرار منطق را میسر میکند و با اجرای نادرست برخی قوانین تجاری، وضعیت سیستم را خراب میکند

# پیاده‌سازی:
مدل دامنه یک مدل شی از دامنه است که هم رفتار و هم داده‌ها را در بر می‌گیرد. الگوهای تاکتیکی DDD - مجموع‌ها، اشیاء ارزش، رویدادهای دامنه و خدمات دامنه - بلوک‌های سازنده چنین مدل شی هستند. همه این الگوها  منطق تجاری را در اولویت قرار می دهند

# پیچیدگی:
منطق تحاری دامنه ذاتا پیچیده است، بنابراین در مدلسازی آن نباید پیچیدگی اضافی ایجاد کرد. مدل نباید درگیر نگرانی‌های زیرساختی و موارد مربوط به تکنولوژی باشد(مثه فراخوانی به پایگاه داده یا سایر اجزای خارجی سیستم) این محدودیت نیازمند آن است که اشیا مدل، اشیا قدیمی ساده باشند، اشیایی که منطق تجاری رو بدون تکیه و ترکیب مستقیم چارچوب زیرساختی پیاده سازی میکنند

# زبان فراگیر:
تاکید بر منطق تجاری به جای نگرانی های فنی، پیروی از اصطلاحات زبان فراگیر بافت محدود را برای اشیاء مدل دامنه آسان تر می کند. به عبارت دیگر، این الگو به کد اجازه می‌دهد تا به زبان فراگیر صحبت کند و از مدل‌های ذهنی متخصصان حوزه پیروی کند

بلوک‌های ساختمانی:
بیایید به بلوک‌های ساختمانی مدل دامنه مرکزی یا الگوهای تاکتیکی ارائه‌شده توسط DDD نگاهی بیندازیم: اشیاء ارزشvalue object، مجموعه‌ها aggregate و خدمات دامنه domain service


# شئ ارزش value object:
شئی است که با ترکیب مقادیر آن قابل شناسایی است (بجای هویت با خصوصیات آن شناسایی می‌شود)

برای مثال به کلاس فرد دقت کنید
</div>

```
class Person:
    phone:int
    name:str
    email:str
```
<div align="justify" dir="rtl">

این کلاس میتواند هر مقداری رو بگیرد و هیچگونه مقدار یکتایی رو نمیده، تیکه بر انواع داده‌های ابتدایی کتابخانه استاندارد زبان   مانند رشته‌ها و اعداد صحیح برای نمایش مفاهیم حوزه کسب و کار بعنوان بوی کد اولیه obsession شناخته میشود، سیستم به کاربر نمیتواند اعتماد کند که همیشه مقادیر صحیح وارد کند لذا لازم است مقادیر اعتبارسنجی شود، این رویکرد ریسک های طراحی متعددی را ارائه می دهد. اول، منطق اعتبارسنجی تمایل به تکرار دارد.  دوم، اجرای فراخوانی منطق اعتبارسنجی قبل از استفاده از مقادیر، دشوار است. در آینده، زمانی که پایه کد توسط مهندسان دیگر تکامل یابد، چالش برانگیزتر خواهد شد. به مقدار اصلاح شده زیر نگاه کنید
</div>

```
class Person:
    phone:Phone
    name:Name
    email:Email
```
<div align="justify" dir="rtl">

ابتدا وضوح در آن افزایش یافته است و در زبان فراگیر در حوزه کسب و کار، مفاهیم با همین اسامی صدا زده میشوند، دوم، نیازی به اعتبارسنجی مقادیر قبل از تخصیص نیست، زیرا منطق اعتبارسنجی در خود اشیاء ارزش قرار دارد. با این حال، رفتار یک شیء ارزشی به اعتبارسنجی صرف محدود نمی شود. اشیاء ارزشی زمانی که منطق تجاری را که ارزش ها را دستکاری می کند متمرکز می کنند، درخشانتر می‌شود. منطق منسجم در یک مکان پیاده سازی شده است و به راحتی قابل آزمایش است.

اشیاء ارزش نیاز به قراردادها را از بین می‌برند، برای مثال: نیاز به در نظر گرفتن این نکته که این رشته یک ایمیل است و رشته دیگر یک شماره تلفن است، و در عوض با استفاده از مدل شی ایجاد می‌کند. کمتر مستعد خطا و شهودی تر می‌باشد

# زمان استفاده از اشیاء ارزشی
پاسخ ساده این است که هر زمان که بتوانید.  نه تنها اشیاء ارزش کد را گویاتر می‌کنند و منطق تجاری را که تمایل به پراکندگی دارند در بر می‌گیرد، بلکه الگوی کد را ایمن‌تر می‌کند.  از آنجایی که اشیاء ارزشی تغییرناپذیر هستند، رفتار اشیای ارزشی عاری از عوارض جانبی بوده و به صورت نخ است.

# موجودیت‌ها:
یک موجودیت مخالف یک شیء ارزشی است. برای تمایز بین نمونه‌های مختلف موجودیت، به یک فیلد شناسایی صریح نیاز دارد 


سناریوهای تجاری وجود دارد که در آنها چندین شی باید، یک مرز معاملاتی را به اشتراک بگذارند. به عنوان مثال، زمانی که هر دو را می‌توان به طور همزمان تغییر داد یا قوانین تجاری یک شی به وضعیت یک شی دیگر بستگی دارد. DDD تجویز می کند که طراحی یک سیستم باید توسط دامنه تجاری آن هدایت شود. تجمیع نیز از این قاعده مستثنی نیستند. برای پشتیبانی از تغییرات در اشیاء متعددی که باید در یک تراکنش اتمی اعمال شوند، الگوی تجمیع شبیه سلسله مراتبی از موجودیت‌ها است. سلسله مراتب شامل هر دو موجودیت و اشیاء ارزشی است و همه آنها در صورتی که به منطق تجاری دامنه محدود شوند به یک تجمیع تعلق دارند. به همین دلیل است که این الگو «تجمیع» نامیده می‌شود: این الگو نهادهای تجاری و اشیاء ارزشی را که به یک مرز معامله تعلق دارند، جمع‌آوری می‌کند. نمونه کد زیر یک قانون کسب‌وکار را نشان می‌دهد که چندین نهاد متعلق به مرز کل را در بر می‌گیرد. تجمیع تضمین می‌کند که همه شرایط در برابر داده‌های کاملاً سازگار بررسی می‌شوند، و پس از تکمیل بررسی‌ها با اطمینان از اینکه همه تغییرات در داده‌های کل به‌عنوان یک تراکنش اتمی انجام می‌شوند، تغییری نمی‌کند.

# ارجاع به سایر تجمیع‌ها:
از آنجایی که تمام اشیاء موجود در یک تجمیع دارای مرز تراکنشی یکسانی هستند، در صورت بزرگ شدن بیش از حد یک تجمیع، ممکن است مسائل مربوط به عملکرد و مقیاس پذیری ایجاد شود. سازگاری داده ها می تواند یک اصل راهنمای مناسب برای طراحی مرزهای یک تجمیع باشد. فقط اطلاعاتی که توسط منطق تجاری کل مورد نیاز است تا به شدت سازگار باشد باید بخشی از کل باشد. تمام اطلاعاتی که در نهایت می‌توانند سازگار باشند، باید خارج از مرز تجمیع باشند. قاعده کلی این است که تجمیع‌ها تا حد امکان کوچک نگه داشته شوند و فقط اشیایی را در بر گیرد که طبق منطق تجاری تجمیع باید در یک حالت کاملاً سازگار باشند

# ریشه تجمیع aggregate root:
با اسامی موجودیت ریشه root entity نیز شناخته می‌شود 
وضعیت یک تجمیع فقط با اجرای یکی از دستورات آن قابل تغییر است. از آنجایی که یک تجمیع نشان دهنده سلسله مراتبی از موجودیت ها است (هر تجمیع می‌تواند شامل چند موجودیت باشد)، تنها یکی از آنها باید به عنوان رابط عمومی تجمیع تعیین شود. برای مثال در بافت محدود به سیستم تیکتینگ و موجودیت‌های آن که شامل ticket, messages, attachments ، میشود ticket بعنوان root شناخته میشود

علاوه بر رابط عمومی ریشه تجمیع، مکانیسم دیگری وجود دارد که از طریق آن دنیای بیرونی می تواند با تجمیع‌ها ارتباط برقرار کند: رویدادهای دامنه domain events

# رویدادهای دامنه domain events:
رویداد دامنه پیامی است که رویداد مهمی را که در حوزه کسب و کار رخ داده است توصیف می کند. برای مثال: بلیط اختصاص داده شده، بلیط افزایش یافته،پیام دریافت شده.
از آنجایی که رویدادهای دامنه چیزی را توصیف می کنند که قبلاً اتفاق افتاده است، نام آنها باید در زمان گذشته فرموله شود. هدف یک رویداد دامنه توصیف آنچه در حوزه کسب و کار اتفاق افتاده و ارائه تمام داده های لازم مربوط به رویداد است. به عنوان مثال، رویداد دامنه زیر نشان می دهد که بلیط خاص، در چه زمانی و به چه دلیل افزایش یافته است

مانند همه چیز در مهندسی نرم افزار، نامگذاری نیز مهم است. اطمینان حاصل کنید که نام رویدادهای دامنه به طور خلاصه منعکس کننده آنچه در حوزه کسب و کار اتفاق افتاده است. رویدادهای دامنه بخشی از رابط عمومی یک مجموعه هستند. یک مجموعه رویدادهای دامنه خود را منتشر می کند. سایر فرآیندها، تجمیع‌ها یا حتی سیستم‌های خارجی می‌توانند در پاسخ به رویدادهای دامنه، مشترک شوند و منطق خود را اجرا کنند

# زبان فراگیر:
آخرین اما نه کم‌اهمیت‌ترین، تجمیع‌ها باید انعکاسی از زبان فراگیر باشند. اصطلاحاتی که برای نام تجمیع، اعضای داده‌های آن، اقدامات و رویدادهای دامنه آن استفاده می‌شود، همگی باید به زبان فراگیر بافت محدود فرموله شوند. کد باید بر اساس همان زبانی باشد که توسعه دهندگان هنگام صحبت با یکدیگر و با کارشناسان حوزه از آن استفاده می کنند. این امر به ویژه برای اجرای منطق پیچیده تجاری مهم است

# خدمات دامنه domain service:
دیر یا زود، ممکن است با منطق تجاری مواجه شوید که یا به هیچ شیء تجمیع یا ارزشی تعلق ندارد، یا به نظر می رسد که به چندین مجموعه مرتبط باشد. در چنین مواردی، طراحی دامنه محور پیشنهاد می کند که منطق را به عنوان یک سرویس دامنه پیاده سازی کند. یک سرویس دامنه یک شیء بدون حالت است که منطق تجاری را پیاده سازی می کند. در اکثریت قریب به اتفاق موارد، چنین منطقی فراخوانی به اجزای مختلف سیستم را برای انجام برخی محاسبات یا تجزیه و تحلیل هماهنگ می کند.

خدمات دامنه، هماهنگی بین چندین مجموعه را آسان می کند.اما مهم است که همیشه محدودیت الگوی تحمیع را برای اصلاح تنها یک نمونه از یک مجموعه در یک تراکنش پایگاه داده در نظر داشته باشید(خدمات دامنه یک راه گریز برای آن نیست) قانون یک نمونه در هر تراکنش همچنان وجود دارد. در عوض، سرویس‌های دامنه خود را به پیاده‌سازی منطق محاسباتی که نیازمند خواندن داده‌های چند مجموعه است، می‌دهند. سرویس دامنه فقط یک شیء بدون حالت است که برای میزبانی منطق تجاری استفاده می شود.

# مدیریت پیچیدگی:
همانطور که در مقدمه این فصل اشاره شد، الگوهای شی تجمیع و ارزش به عنوان ابزاری برای مقابله با پیچیدگی در اجرای منطق تجاری معرفی شدند. بیایید دلیل پشت این موضوع را ببینیم

### به گفته گلدرات، هنگام بحث در مورد پیچیدگی یک سیستم، ما علاقه مندیم که دشواری کنترل و پیش بینی رفتار سیستم را ارزیابی کنیم.  این دو جنبه توسط درجات آزادی سیستم منعکس می شود. درجات آزادی یک سیستم، نقاط داده مورد نیاز برای توصیف وضعیت آن است

الگوهای شی تجمیع و ارزش، ثابت ها را محصور می کنند و در نتیجه پیچیدگی را کاهش می دهند.
تمام منطق تجاری مربوط به وضعیت یک شی ارزش در مرزهای آن قرار دارد.
همین امر در مورد سنگدانه ها نیز صادق است.  یک مجموعه را فقط می توان با روش های خاص خود اصلاح کرد. منطق تجاری آن، متغیرهای کسب و کار را محصور می کند و از آن محافظت می کند، بنابراین درجات آزادی را کاهش می دهد.
از آنجایی که الگوی مدل دامنه فقط برای زیر دامنه‌هایی با منطق تجاری پیچیده اعمال می‌شود، می‌توان فرض کرد که اینها زیردامنه‌های اصلی - قلب نرم‌افزار هستند.

</div>



[نویسنده: بهزاد آزادی](https://github.com/behzad-azadi2693)

[وب سایت](https://codecrafters.ir)

[کانال تلگرامی](https://t.me/Code_Crafters)